% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dispatch.R
\name{dispatch2}
\alias{dispatch2}
\alias{dispatch2_}
\alias{def_method2}
\title{Binary dispatch}
\usage{
dispatch2(generic, x, y, env = caller_env(2L))

dispatch2_(.generic, .x, .y, ..., .env)

def_method2(.class1, .class2, ..., .env = caller_env())
}
\arguments{
\item{generic, .generic}{The name of the generic as a string.}

\item{x, y, .x, .y}{Objects to dispatch on.}

\item{env, .env}{The environment in which to find or define methods.}

\item{...}{For \code{def_method2()}, named methods to be defined in
\code{.env}. For \code{dispatch2_()}, further arguments to be passed on to
the selected method.}

\item{.class1, .class2}{Classes to define methods on. Must be length
1 strings.}
}
\description{
\code{dispatch2()} dispatches to binary methods defined with
\code{def_method2()} based on the classes of \code{x} and \code{y}.
\itemize{
\item \code{dispatch2()} is meant to be called within a generic wrapper and
forwards arguments automatically.
\item \code{dispatch2_()} with an underscore requires manual forwarding of
arguments.
}

\code{dispatch2()} is a binary version of \code{\link[base:UseMethod]{base::UseMethod()}}.
\code{def_method2()} has no S3 equivalent but is similar to the S4
operator \code{\link[methods:setMethod]{methods::setMethod()}}.
}
\section{Semantics}{

\itemize{
\item Dispatch is symmetric but not necessarily commutative. The same
method is always called for two given types (symmetric
dispatch). However the return value might be different
(non-commutativity).
\item Method definition is commutative: \code{def_method2(c1, c2, ...)} is
equivalent to \code{def_method2(c2, c1, ...)}. The ordering of the
method arguments is never changed (and they could be of class
\code{c1} or \code{c2}) but you can access the arguments through the
\code{.dispatched} pronoun, e.g. \code{.dispatched$c1}.
\item Dispatch is lexically scoped. Methods are only looked up in \code{env}
and its ancestors. Calling \code{def_method2()} for a method that
already exists in an environment gives a warning.
\item Binary dispatch enforces specialisation: no inheritance is
allowed. However you can specify default methods by supplying the
\code{"*"} wildcard as classes.
}
}

\examples{
is_congruent <- function(x, y) {
  dispatch2("is_congruent", x, y)
}

# `x` and `y` are as supplied by the user and so could each be a
# factor or a character vector. However we can access these
# arguments through the `.dispatched` pronoun:
def_method2("factor", "character",
  is_congruent = function(x, y, ...) {
    fct <- .dispatched$factor
    chr <- .dispatched$character
    all(chr \%in\% levels(fct))
  }
)

# You can also supply a method for objects of the same class:
def_method2("factor", "factor",
  is_congruent = function(x, y, ...) {
    all(levels(x) \%in\% levels(y))
  }
)

f <- factor(c("foo", "bar"))
is_congruent(f, "foo")
is_congruent(f, "baz")

is_congruent(f, factor("bar"))
is_congruent(f, factor(c("bar", "foo")))


# While there is no inheritance of methods with binary dispatch, you
# can define a default method with the wildcard "*":
def_method2("*", "*",
  is_congruent = function(x, y, ...) {
    inform("Don't know how to determine congruence")
    FALSE
  }
)
is_congruent("foo", 10)


# You can also define several methods at once:
equals <- function(x, y) {
  dispatch2("equals", x, y)
}

def_method2("integer", "numeric",
  is_congruent = function(x, y, ...) {
    is_integerish(.dispatched$numeric)
  },
  equals = function(x, y, ...) {
    all(x == y)
  }
)

is_congruent(1:3, c(4, 5))
}
\seealso{
\code{\link[=get_method2]{get_method2()}}
}
