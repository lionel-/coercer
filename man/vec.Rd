% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/vec.R
\name{vec}
\alias{vec}
\title{Concatenate objects in a single vector}
\usage{
vec(...)
}
\arguments{
\item{...}{Objects to concatenate.}
}
\description{
\code{vec()} is like \code{\link[base:c]{base::c()}} but uses an extensible mechanism for
coercions of elements to concatenate.

Note that only the binary case is guaranteed to be symmetric. The
ordering of elements may have an influence on the return type and
\code{vec()} may be sensitive on permutations of arguments.
}
\section{Determination of return type}{


The coercion mechanism uses the binary generic \code{\link[=vec_coerce]{vec_coerce()}}:
\itemize{
\item A return type is first decided by reducing \code{vec_coerce()} over
empty versions of the vectors in \code{...}.
\item All elements in \code{...} are then coerced to that return type.
}
}

\examples{
# In simple cases vec() works like c():
vec(1, 2L, TRUE)
c(1, 2L, TRUE)

# However it supports more types and is extensible:
foo <- factor("foo")
vec(foo, foo)

# Warnings are consistently thrown when information is lost because
# of coercions:
vec(foo, "bar")

# NA is always promoted to whichever type
fct <- factor(c("foo", "bar"))
vec(fct, NA)

# Incompatible types are promoted to list in order to preserve
# information:
vec(1L, TRUE, "foo")
vec(fct, 1L)
}
